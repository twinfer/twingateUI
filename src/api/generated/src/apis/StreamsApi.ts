/* tslint:disable */
/* eslint-disable */
/**
 * TwinCore Gateway API
 * TwinCore Gateway is a Web of Things (WoT) gateway that manages IoT devices through W3C Thing Descriptions. It dynamically generates data processing pipelines using Benthos and exposes HTTP APIs for device interaction.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@twinfer.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  TypesErrorResponse,
  TypesStreamCreationRequest,
  TypesStreamInfo,
} from '../models/index';
import {
    TypesErrorResponseFromJSON,
    TypesErrorResponseToJSON,
    TypesStreamCreationRequestFromJSON,
    TypesStreamCreationRequestToJSON,
    TypesStreamInfoFromJSON,
    TypesStreamInfoToJSON,
} from '../models/index';

export interface ApiStreamsGetRequest {
    thingId?: string;
    status?: string;
    interactionType?: string;
    limit?: number;
    offset?: number;
}

export interface ApiStreamsIdGetRequest {
    id: string;
}

export interface ApiStreamsIdStartPostRequest {
    id: string;
}

export interface ApiStreamsIdStopPostRequest {
    id: string;
}

export interface ApiStreamsPostRequest {
    stream: TypesStreamCreationRequest;
}

/**
 * StreamsApi - interface
 * 
 * @export
 * @interface StreamsApiInterface
 */
export interface StreamsApiInterface {
    /**
     * Retrieve all Benthos streams with optional filtering
     * @summary List all streams
     * @param {string} [thingId] Filter by Thing ID
     * @param {string} [status] Filter by stream status (running, stopped, error)
     * @param {string} [interactionType] Filter by interaction type (property, action, event)
     * @param {number} [limit] Maximum number of results (1-1000)
     * @param {number} [offset] Number of results to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApiInterface
     */
    apiStreamsGetRaw(requestParameters: ApiStreamsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>>;

    /**
     * Retrieve all Benthos streams with optional filtering
     * List all streams
     */
    apiStreamsGet(requestParameters: ApiStreamsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }>;

    /**
     * Retrieve a specific Benthos stream by ID
     * @summary Get stream by ID
     * @param {string} id Stream ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApiInterface
     */
    apiStreamsIdGetRaw(requestParameters: ApiStreamsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TypesStreamInfo>>;

    /**
     * Retrieve a specific Benthos stream by ID
     * Get stream by ID
     */
    apiStreamsIdGet(requestParameters: ApiStreamsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TypesStreamInfo>;

    /**
     * Start a stopped Benthos stream
     * @summary Start a stream
     * @param {string} id Stream ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApiInterface
     */
    apiStreamsIdStartPostRaw(requestParameters: ApiStreamsIdStartPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>>;

    /**
     * Start a stopped Benthos stream
     * Start a stream
     */
    apiStreamsIdStartPost(requestParameters: ApiStreamsIdStartPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }>;

    /**
     * Stop a running Benthos stream
     * @summary Stop a stream
     * @param {string} id Stream ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApiInterface
     */
    apiStreamsIdStopPostRaw(requestParameters: ApiStreamsIdStopPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>>;

    /**
     * Stop a running Benthos stream
     * Stop a stream
     */
    apiStreamsIdStopPost(requestParameters: ApiStreamsIdStopPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }>;

    /**
     * Create a new Benthos stream configuration
     * @summary Create a new stream
     * @param {TypesStreamCreationRequest} stream Stream creation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApiInterface
     */
    apiStreamsPostRaw(requestParameters: ApiStreamsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TypesStreamInfo>>;

    /**
     * Create a new Benthos stream configuration
     * Create a new stream
     */
    apiStreamsPost(requestParameters: ApiStreamsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TypesStreamInfo>;

}

/**
 * 
 */
export class StreamsApi extends runtime.BaseAPI implements StreamsApiInterface {

    /**
     * Retrieve all Benthos streams with optional filtering
     * List all streams
     */
    async apiStreamsGetRaw(requestParameters: ApiStreamsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>> {
        const queryParameters: any = {};

        if (requestParameters['thingId'] != null) {
            queryParameters['thing_id'] = requestParameters['thingId'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['interactionType'] != null) {
            queryParameters['interaction_type'] = requestParameters['interactionType'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }

        const response = await this.request({
            path: `/api/streams`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieve all Benthos streams with optional filtering
     * List all streams
     */
    async apiStreamsGet(requestParameters: ApiStreamsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }> {
        const response = await this.apiStreamsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a specific Benthos stream by ID
     * Get stream by ID
     */
    async apiStreamsIdGetRaw(requestParameters: ApiStreamsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TypesStreamInfo>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStreamsIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }

        const response = await this.request({
            path: `/api/streams/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TypesStreamInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve a specific Benthos stream by ID
     * Get stream by ID
     */
    async apiStreamsIdGet(requestParameters: ApiStreamsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TypesStreamInfo> {
        const response = await this.apiStreamsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Start a stopped Benthos stream
     * Start a stream
     */
    async apiStreamsIdStartPostRaw(requestParameters: ApiStreamsIdStartPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStreamsIdStartPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }

        const response = await this.request({
            path: `/api/streams/{id}/start`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Start a stopped Benthos stream
     * Start a stream
     */
    async apiStreamsIdStartPost(requestParameters: ApiStreamsIdStartPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }> {
        const response = await this.apiStreamsIdStartPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stop a running Benthos stream
     * Stop a stream
     */
    async apiStreamsIdStopPostRaw(requestParameters: ApiStreamsIdStopPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStreamsIdStopPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }

        const response = await this.request({
            path: `/api/streams/{id}/stop`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Stop a running Benthos stream
     * Stop a stream
     */
    async apiStreamsIdStopPost(requestParameters: ApiStreamsIdStopPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }> {
        const response = await this.apiStreamsIdStopPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new Benthos stream configuration
     * Create a new stream
     */
    async apiStreamsPostRaw(requestParameters: ApiStreamsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TypesStreamInfo>> {
        if (requestParameters['stream'] == null) {
            throw new runtime.RequiredError(
                'stream',
                'Required parameter "stream" was null or undefined when calling apiStreamsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }

        const response = await this.request({
            path: `/api/streams`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TypesStreamCreationRequestToJSON(requestParameters['stream']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TypesStreamInfoFromJSON(jsonValue));
    }

    /**
     * Create a new Benthos stream configuration
     * Create a new stream
     */
    async apiStreamsPost(requestParameters: ApiStreamsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TypesStreamInfo> {
        const response = await this.apiStreamsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
